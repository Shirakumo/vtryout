(in-package #:org.shirakumo.fraf.vtryout)

(defclass actor-pose ()
  ((jaw-open :initform 0f0 :accessor jaw-open)
   (mouth-stretch :initform 1f0 :accessor mouth-stretch)
   (mouth-smile :initform 0f0 :accessor mouth-smile)
   (head-location :initform (vec3) :accessor head-location)
   (head-rotation :initform (quat) :accessor head-rotation)
   (brow-left :initform 0f0 :accessor brow-left)
   (brow-right :initform 0f0 :accessor brow-right)
   (brow-angle-left :initform 0f0 :accessor brow-angle-left)
   (brow-angle-right :initform 0f0 :accessor brow-angle-right)
   (blink-left :initform 0f0 :accessor blink-left)
   (blink-right :initform 0f0 :accessor blink-right)
   (eye-left :initform (quat) :accessor eye-left)
   (eye-right :initform (quat) :accessor eye-right)))

(define-shader-entity actor (basic-animation-controller)
  ((actor-pose :initform (make-instance 'actor-pose) :accessor actor-pose)))

(defmethod shared-initialize :after ((actor actor) slots &key layers)
  (dolist (layer layers)
    (destructuring-bind (name &optional (strength 1.0)) (enlist layer)
      (add-animation-layer name actor :strength strength :if-exists :supersede))))

(defmethod fk-update ((actor actor) pose tt dt fc)
  (let ((skeleton (skeleton actor))
        (joints (joints pose))
        (pose (actor-pose actor)))
    (labels ((adjust-joint (name &key quat scale offset)
               (let* ((index (trial:node name skeleton))
                      (joint (aref joints index)))
                 (when offset (nv+ (tlocation joint) offset))
                 (when quat (nq* (trotation joint) quat))
                 (when scale (nv* (tscaling joint) scale))
                 joint))
             (adjust-joint/angle (name &key x y z)
               (let ((quat (quat)))
                 (declare (dynamic-extent quat))
                 (when x (!qfrom-angle quat +vx+ x))
                 (when y (!qfrom-angle quat +vy+ y))
                 (when z (!qfrom-angle quat +vz+ z))
                 (adjust-joint name :quat quat)))
             (adjust-joint/offset (name &key (x 0.0) (y 0.0) (z 0.0))
               (let ((vec (vec3 x y z)))
                 (declare (dynamic-extent vec))
                 (adjust-joint name :offset vec))))
      (let ((open (jaw-open pose)))
        (cond ((< 0 open)
               (adjust-joint/angle :MCH-JAW-MASTER-BOTTOM :x open)
               (adjust-joint/angle :JAW-MASTER :x open))
              (T
               ;; Press lips together
               )))
      (let ((wide (mouth-stretch pose)))
        (adjust-joint :MCH-JAW-MASTER-TOP :scale (vec3 wide 1 1))
        (adjust-joint :MCH-JAW-MASTER-BOTTOM :scale (vec3 wide 1 1)))
      (adjust-joint :ORG-SPINE.006 :quat (head-rotation pose))
      (adjust-joint :DEF-SPINE.006 :quat (head-rotation pose))
      (adjust-joint :ORG-SPINE.006 :offset (head-location pose))
      (adjust-joint :DEF-SPINE.006 :offset (head-location pose))
      (adjust-joint/angle :DEF-LID.-T.-L :x (blink-left pose))
      (adjust-joint/angle :DEF-LID.-T.-R :x (blink-right pose))
      ;;(adjust-joint :DEF-EYE.-R :quat (eye-left pose))
      ;;(adjust-joint :DEF-EYE.-L :quat (eye-right pose))
      (let ((smile (mouth-smile pose)))
        (adjust-joint/angle :DEF-LIP.-T.-L.001 :x smile)
        (adjust-joint/angle :DEF-LIP.-B.-L.001 :x smile)
        (adjust-joint/angle :DEF-LIP.-T.-R.001 :x smile)
        (adjust-joint/angle :DEF-LIP.-B.-R.001 :x smile))
      (let ((brow (brow-left pose)))
        (adjust-joint/offset :DEF-BROW.-T.-L.001 :y brow)
        (adjust-joint/offset :DEF-BROW.-T.-L.002 :y brow)
        (adjust-joint/offset :DEF-BROW.-T.-L.003 :y brow))
      (let ((brow (brow-right pose)))
        (adjust-joint/offset :DEF-BROW.-T.-R.001 :y brow)
        (adjust-joint/offset :DEF-BROW.-T.-R.002 :y brow)
        (adjust-joint/offset :DEF-BROW.-T.-R.003 :y brow)
        ))))

;; KLUDGE
(defmethod enter :after ((entity animated-entity) (controller animation-controller))
  (setf (animation-controller entity) controller))

(define-handler (actor face-update) (local-transform packet)
  (let ((pose (actor-pose actor)))
    (macrolet ((update (via place new &optional (rate 0.5))
                 `(setf ,place (,via ,place ,new ,rate))))
      (update lerp (jaw-open pose) (* 0.3 (packet-mouth-open packet)))
      (update lerp (mouth-stretch pose) (+ 1.0 (* 0.3 (packet-mouth-wide packet))))
      (update lerp (mouth-smile pose) (lerp (- (aref (packet-mouth-left packet) 0))
                                            (- (aref (packet-mouth-right packet) 0))
                                            0.5))
      (update lerp (brow-left pose) (* 0.15 (aref (packet-eyebrow-left packet) 1)))
      (update lerp (brow-right pose) (* 0.15 (aref (packet-eyebrow-right packet) 1)))
      (update lerp (brow-angle-left pose) (- (aref (packet-eyebrow-left packet) 0)))
      (update lerp (brow-angle-right pose) (- (aref (packet-eyebrow-right packet) 0)))
      ;;(update vlerp (head-location pose) (tlocation local-transform))
      (q<- (head-rotation pose) (trotation local-transform))
      (update lerp (blink-left pose) (max -0.7 (+ -1.0 (packet-blink-left packet))))
      (update lerp (blink-right pose) (max -0.7 (+ -1.0 (packet-blink-right packet))))
      (update qnlerp (eye-left pose) (qfrom-angle +vx+ (- (* 0.5 (packet-eye-left packet)) 0.4)))
      (update qnlerp (eye-right pose) (qfrom-angle +vx+ (- (* 0.5 (packet-eye-right packet)) 0.4))))))

(defun actor (&optional name)
  (do-scene-graph (node (scene +main+))
    (when (and (typep node 'actor)
               (or (not name) (eql name (name node))))
      (return node))))

(defun toggle-layer (name &key (actor (actor)) (strength 1.0))
  (if (animation-layer name actor)
      (remove-animation-layer name actor)
      (add-animation-layer name actor :strength strength)))

(defun activate-camera (name &optional (scene (scene +main+)))
  (with-simple-restart (continue "Don't activate the camera")
    (do-scene-graph (node (node name scene) (error "No camera named ~s" name))
      (when (typep node 'camera)
        (activate node)
        (return)))))

(defun activate-next-camera (&optional (scene (scene +main+)))
  (let ((found NIL))
    (or (do-scene-graph (node scene)
          (when (typep node 'camera)
            (cond ((eq node (camera scene))
                   (setf found T))
                  (found
                   (return (activate node))))))
        (do-scene-graph (node scene)
          (when (typep node 'camera)
            (return (activate node)))))))

(defun activate-prev-camera (&optional (scene (scene +main+)))
  (let ((prev NIL))
    (or (do-scene-graph (node scene)
          (when (typep node 'camera)
            (cond ((and prev (eq node (camera scene)))
                   (return (activate prev)))
                  (T
                   (setf prev node)))))
        (when prev
          (activate prev)))))
